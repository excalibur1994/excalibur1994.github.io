<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Spring零碎知识收集</title>
      <link href="/2018/05/23/Spring%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E6%94%B6%E9%9B%86/"/>
      <url>/2018/05/23/Spring%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E6%94%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1526290577726.jpg" alt=""></p><p>这篇博客主要是对《Spring实战》以及日常工作时发现的一些有关Spring的零碎知识进行收集，内容可能会很多而且不一定全都有用，当作一本字典食用即可。</p><a id="more"></a><ul><li>@DateTimeFormat<ul><li>这个注解一般用在实体类的Date类型属性上，它可以将页面传递来的String类型日期转换为Date类型，但在4.0之前强依赖于joda-time.jar    ，必须要引入这个包才可以使用，4.0之后不再强依赖于这个jar包。</li></ul></li><li>&lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/fmt&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/fmt&quot;</a> prefix=”fmt” %&gt;<ul><li>这是一个jstl标签，其中有很多格式化的方法，比如格式化日期，数字等等，此处只做一个简单的记录，有需求可以直接百度，食用度不难。</li></ul></li><li>@Configuration <ul><li>这个注解相当于xml中的<code>&lt;beans&gt;&lt;beans/&gt;</code>标签，可以表明这个类是一个配置类，在SpringBoot中可能会用的比较多，而且在SpringBoot中不用开启注解扫描也可以直接使用。</li></ul></li><li>@ComponentScan<ul><li>这个注解会开启注解扫描，有属性值value，相当于base-package。一般在配置类上使用，若不配置这个属性，它会默认以配置类所处的包为base-package来扫描组件。</li></ul></li><li>@Component<ul><li>和@Controller，@Service这些用法一样，一般用于实例化实体类。</li></ul></li><li>@Named(“”)<ul><li>这个注解和上一个注解的用处一样，引号中的字符串可以当作bean的别名，@Component也可以通过这种方式来指定别名。</li></ul></li><li>@RunWith（SpringJUnit4ClassRunner.class）<ul><li>这个注解可以用在测试类上，测试时会自动加载Spring上下文。</li></ul></li><li>@ContextConfiguration（class=XXX.class）<ul><li>测试时与上一个注解搭配使用，这个注解可以指明哪一个类是配置类。</li></ul></li><li>@Inject<ul><li>这个注解和@Autowired一样都是用于bean的自动装配，它和@Named注解都来自于Java的依赖注入规范，大部分情况下这两个注解是可以互相替换的。</li></ul></li><li>@Bean（name=””）<ul><li>这个注解相当于XML配置文件中的<code>&lt;bean&gt;&lt;/bean&gt;</code>标签，用于方法上，它可以通知Spring该方法会返回一个对象，这个对像将要注册为Spring应用上下文的bean。用这种方法创建bean时，使我们有了在方法体中执行复杂逻辑的可能性，因为这完全是基于Java代码的，无论逻辑多复杂，只要最终返回一个实力就行。另外当一个方法已经使用了这个注解后，Spring会拦截所有对它的访问，如果它已经创建了一个bean,，就会直接返回这个bean，而不是每次都对其进行实际的调用</li></ul></li><li>Spring配置的三种主要方式<ul><li>自动化配置<ul><li>工作时一般都使用这种方法，目前接触的项目多数情况下还会搭配XML，使用方法一般都是在XML里开启组件扫描，同时配置数据库，事务，拦截器等等，然后在代码中的使用@Controller，@Service，@Autowired这些注解。</li><li>虽然自动化配置很方便，但有些时候必须要显示的进行一些配置，比如在使用第三方的一些组件时，我们就没有办法去给它添加注解，除了上面所说的搭配XML，我们还可以搭配JavaConfig（基于Java的显示配置），使用这种方法时我们会创建一个类来取代XML，当我们为这个类加上@Configuration注解时，它就会被Spring认为是一个配置类，同时Spring也提供了大量的注解来对应XML中的标签，以便我能够实现所有XML中能够实现的功能，而且这种方法比XML更加强大。</li></ul></li><li>基于Java的显示配置<ul><li>正如上面所说的，我们在使用这种方法时可以创建一个类来取代XML，通过@Configuration来申明它是一个配置类，通过@ComponentScan来开启组件扫描，通过@Bean来创建实例等等，可能还有其它许多注解，但此处只做简单描述，未来可能在SpringBoot的学习中详细记录这种方式。</li></ul></li><li>基于XML的显示配置<ul><li>最原始的方法，见过无数次的<code>&lt;bean&gt;&lt;bean/&gt;</code>标签，<code>&lt;property/&gt;</code>标签等等，百度一抓一大把，基本也没什么可说的了。</li></ul></li></ul></li><li>@Import（XXX.calss）<ul><li>这个注解相当与XML中的<code>&lt;import&gt;</code>标签，在4.2前只能导入配置类，在4.2之后，@Import注解支持导入普通的Java类,并将其声明成一个bean ，当一个JavaConfig配置的内容过多，我们可以将其拆分为两个或更多的JavaConfig，通过使用这个注解将多个JavaConfig进行统一。同时也可以使用@Import（｛XXX.class,XXX.class｝）一次引入多个JavaConfig。</li></ul></li><li>@ImportResource(“classpath:”)<ul><li>这个注解和上一个注解的用处一样，是用来引入XML配置文件的</li></ul></li><li>条件化的bean<ul><li>当我们希望一个bean只有在满足一定的条件下时才会被创建，可以在方法上使用@Conditional（XXX.class）注解，XXX是一个我们自定义的类，它必须实现Condition接口，并且重写matches()方法，当这个方法返回true时，这个bean就会被创建，如果返回false，则不会创建。</li></ul></li><li>@Qualifier(“”)<ul><li>这个注解可以配合@Autowired或@Inject使用，这个注解应用于有一个以上的bean可以匹配自动装配，比如一个接口有三个实现类，在自动装配时使用的参数类型是接口而不是实现类，这时Spring就会无法分辨你想要将哪一个子类注入，便会抛出异常。@Qualifier(“”)注解可以通过在””中指明限定符（默认情况下使用bean的id即可），从而准确的注入我们想要的bean。我们也可以不使用bean的id，自己来定义限定符，将@Qualifier(“”)和@Component，@Bean这类用于实例化的一起使用，””中的内容就是自定义的限定符</li></ul></li><li>@Scope()<ul><li>这个注解是用来声明bean的作用域的，在Spring中默认的作用域为Singleton，我们可以通过value属性将其改变为Prototype(多例)，Session(会话)，Request(请求)</li><li>proxyMode属性：这个属性可以解决将Session或Request作用域的bean注入到单例bean中所遇到的问题。当向一个单例的bean注入Session范围的或Request范围的bean时，它们此时并没有创建，直到一个用户发起了一个会话或进行了一次请求，它们才会被创建。<ul><li>以电子商务中的购物车系统为例，ShoppingCart实例的作用范围都是Session，而处理业务的ShoppingCartService都是单例的，当我们向ShoppingCartService中注入一个ShoppingCart时，这个ShoppingCart可能还没有被创建，直到一个用户发起了一次会话，ShoppingCart才会被创建，另外在向ShoppingCartService注入ShoppingCart时，我们并不希望注入的是一个固定的ShoppingCart实例，我们希望的时当ShoppingCartService处理购物车功能时，它所使用的ShoppingCart正好是当前会话的对应的那一个。所以Spring会注入一个ShoppingCart bean的代理，这个代理会暴露与ShoppingCart相同的方法，所以ShoppingService会认为它就是一个ShoppingsCart，但是在调用ShoppingCart中的方法时，代理会对其进行懒解析并将调用委托给会话作用域内真正的ShoppingCart bean。这个属性有两个常用的值，以ShoppingCart为例，假如ShoppingCart是一个接口，那么proxyMode的值是ScopedProxyMode.INTERFACES，如果ShoppingCart是一个类，那么proxyMode的值是ScopedProxyMode.TARGET_CLASS</li></ul></li><li><code>&lt;aop:scoped-proxy&gt;</code>：这个标签就是XML中proxyMode的用法，默认使用ScopedProxyMode.TARGET_CLASS，也可以将proxy-target-class设为false，将其变成基于接口的代理，需要注意的是使用这个注解需要开启aop命名空间。</li></ul></li><li>Spring中关于AOP的一些注解<ul><li>@EnableAspectJAutoProxy：这个注解可以用在配置类上，作用与组件扫描类似，开启之后可以识别@Aspect注解，如果是在XML中，可以使用Spring aop命名空间中的<code>&lt;aop:aspectj-autoproxy&gt;</code></li><li>@Aspect：这个注解可以标明一个类是切面。</li><li>@Before()：应用这个注解的方法会在目标方法调用之<font color="red">前</font>执行。</li><li>@After()：应用这个注解的方法会在目标方法调用之<font color="red">后</font>执行。</li><li>@AfterReturning()：应用这个注解的方法会在目标方法<font color="red">返回后</font>执行。</li><li>@AfterThrowing()：应用这个注解的方法会在目标方法<font color="red">抛出异常后</font>执行。</li><li>@Around()：应用这个注解的方法会在目标方法<font color="red">执行之前与执行之后</font>执行。</li><li>@Pointcut()：这个注解能够在切面内定义可以复用的切点。</li></ul></li></ul><hr><p>​    </p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring实战第四版</title>
      <link href="/2018/05/12/Spring%E5%AE%9E%E6%88%98%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
      <url>/2018/05/12/Spring%E5%AE%9E%E6%88%98%E7%AC%AC%E5%9B%9B%E7%89%88/</url>
      <content type="html"><![CDATA[<p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1526290577726.jpg" alt=""></p><p>写这篇博客是因为发现虽然平时工作中经常和Spring打交道。但是重复的造车轮工作并没有帮助我更好的去理解它，所以开始研究《Spring实战第四版》这本书，以便对Spring进行更近一步的学习。</p><a id="more"></a><h2 id="Spring基本理念"><a href="#Spring基本理念" class="headerlink" title="Spring基本理念"></a>Spring基本理念</h2><p>Spring最基本的理念就是简化代码开发，再抛开一切外壳之后，最终的基本策略都会回归到以下四点</p><ol><li>基于POJO的轻量级和最小侵入性编程</li><li>通过依赖注入和面向接口实现松耦合</li><li>基于切面和惯例进行声明式编程</li><li>通过切面和模板减少样板式代码</li></ol><h2 id="DI（依赖注入）"><a href="#DI（依赖注入）" class="headerlink" title="DI（依赖注入）"></a>DI（依赖注入）</h2><p>我觉得可以从三个问题来理解一下DI</p><ol><li>什么是DI？</li><li>DI能够做什么？</li><li>它是如何做到的？</li></ol><p>对于第一第二个问题，比较理论化一点，简单描述一下：DI发展到如今，已经变成了一种编程技巧和程序设计理念，它能够极大的降低程序的耦合性，还可以使代码的测试变得简单。</p><p>（关于耦合：这是一个具有两面性的东西，过高的耦合性会使代码难于测试，理解以及复用，同时可能会出现连锁式的BUG，修复好一个，又出现一个或多个新BUG，但完全没有耦合性的代码也没啥用，    想要完成有实际意义的功能，代码之间必须有适当的交互过程）</p><p>至于对于第三个问题可能是需要重点关注的，首先定一个大的基调：依赖注入能够降低高耦合性的问题是因为<font color="red">它不再让调用者来主动创建被调用者的实例，而是将其交给Spring来执行</font></p><h2 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP(面向切面编程)"></a>AOP(面向切面编程)</h2><p>在软件开发中，同一个功能如果散布于应用中多处，我们可以称其为横切关注点。从概念上来说我们应该将其与业务逻辑分离（但是往往会直接嵌入到业务逻辑之中）。AOP要做的就是把这些横切关注点与业务逻辑相分离。</p><p>DI能够实现应用对象之间的解耦，而AOP可以实现横切关注点与它们所影响的对象之间的解耦</p><p>关于AOP术语的理解：通知包含了用于多个应用对象的横切行为，连接点是程序中可以应用通知的所有点，切点定义了通知被应用的具体位置（也可以理解为切点定义了哪些连接点会得到通知），切点与通知的结合称为切面，将切面应用到目标对象并创建新的代理对象叫做织入，在目标对像的生命周期里有多个点可以进行织入</p><ol><li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器，它可以在目标类被引入引用之前增强该目标类的字节码。AspectJ 5的加载时织入就支持以这种方式织入切面</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态的创建一个代理对象。Spring AOP就是以这种方式织入切面的</li></ol><p>关于Spring AOP框架的一些关键知识</p><ol><li>Spring的通知是由Java编写的</li><li>Spring在运行时通知对象：代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean，当代理拦截到方法调用时，在调用目标bean的方法之前，会执行切面逻辑。</li><li>Spring只支持方法级别的连接点</li></ol><p>##</p><hr>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简单写点东西撑撑首页</title>
      <link href="/2018/05/11/%E7%AE%80%E5%8D%95%E5%86%99%E7%82%B9%E4%B8%9C%E8%A5%BF%E6%92%91%E6%92%91%E9%A6%96%E9%A1%B5/"/>
      <url>/2018/05/11/%E7%AE%80%E5%8D%95%E5%86%99%E7%82%B9%E4%B8%9C%E8%A5%BF%E6%92%91%E6%92%91%E9%A6%96%E9%A1%B5/</url>
      <content type="html"><![CDATA[<h3 id="来自博主的碎碎念"><a href="#来自博主的碎碎念" class="headerlink" title="来自博主的碎碎念"></a><center>来自博主的碎碎念<center></center></center></h3><a id="more"></a><blockquote class="blockquote-center"><p>嗯，闲鱼玩家终于也有的自己的博客了</p><p>激动ING</p><p>虽然布局很一般，但是会慢慢优化的（才怪）</p><p>毕竟博主是一个专业的前端工程师（手动滑稽）</p><p>CSS什么的根本不（wan）在（quan）话（bu）下（dong）</p><p>凭借我出色的审美</p><p>一定<del>不</del>会好好考虑如何搭配颜色，合理布局的</p><p>相信假以时日这个博客必定能够红红火火恍恍惚惚哈哈哈哈</p><hr><p>来自没有良心的博主(大英雄，你np满了)</p></blockquote>]]></content>
      
      <categories>
          
          <category> 即兴乱写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BB </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
