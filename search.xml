<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Ehcache食用教程</title>
      <link href="/2018/06/05/Ehcache%E9%A3%9F%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2018/06/05/Ehcache%E9%A3%9F%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528193012116.png" alt=""></p><a id="more"></a><h2 id="为什么使用Eacache"><a href="#为什么使用Eacache" class="headerlink" title="为什么使用Eacache"></a>为什么使用Eacache</h2><p>为了提高系统的运行效率，引入Ehcache可以减少对数据库的访问</p><h2 id="Eacache与Redis的取舍问题"><a href="#Eacache与Redis的取舍问题" class="headerlink" title="Eacache与Redis的取舍问题"></a>Eacache与Redis的取舍问题</h2><p>ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。<br>redis是通过socket访问到缓存服务，效率比ecache低，比数据库要快很多，处理集群和分布式缓存方便，有成熟的方案。</p><p>如果是单个应用或者对缓存访问要求很高的应用，用ehcache。<br>如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><font color="red">Encache所需要的jar包（版本可以自行更换）</font><ul><li>slf4j-api-1.6.1.jar</li><li>ehcache-core-2.1.0.jar</li><li>ehcache-spring-annotations-1.1.2.jar；</li><li>slf4j-log4j12-1.6.1.jar</li><li>spring-context-support-4.0.6.RELEASE.jar</li></ul><font color="red">创建ehcache.xml</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line"> &lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt;  </span><br><span class="line">      </span><br><span class="line">     &lt;!-- 缓存存储的位置 --&gt;</span><br><span class="line">     &lt;diskStore path=&quot;E：/ehcache&quot;/&gt;  </span><br><span class="line">       </span><br><span class="line">     &lt;!-- 默认缓存 --&gt;  </span><br><span class="line">     &lt;defaultCache  </span><br><span class="line">            maxElementsInMemory=&quot;1000&quot;  </span><br><span class="line">            eternal=&quot;false&quot;  </span><br><span class="line">            timeToIdleSeconds=&quot;120&quot;  </span><br><span class="line">            timeToLiveSeconds=&quot;120&quot;  </span><br><span class="line">            overflowToDisk=&quot;false&quot;/&gt;  </span><br><span class="line">              </span><br><span class="line">     &lt;!-- 自定义的缓存 --&gt;      </span><br><span class="line">     &lt;cache name=&quot;myCache&quot;   </span><br><span class="line">            maxElementsInMemory=&quot;1000&quot;   </span><br><span class="line">            eternal=&quot;false&quot;  </span><br><span class="line">            timeToIdleSeconds=&quot;120&quot;  </span><br><span class="line">            timeToLiveSeconds=&quot;120&quot;  </span><br><span class="line">            overflowToDisk=&quot;false&quot;   </span><br><span class="line">            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;  </span><br><span class="line">       </span><br><span class="line"> &lt;/ehcache&gt;</span><br></pre></td></tr></table></figure><p><strong>name</strong>：缓存名称,cache的唯一标识(ehcache会把这个cache放到HashMap里)。</p><p><strong>maxElementsOnDisk</strong>：磁盘缓存中最多可以存放的元素数量,0表示无穷大。</p><p><strong>maxElementsInMemory</strong>：内存缓存中最多可以存放的元素数量,若放入Cache中的元素超过这个数值,则有以下两种情况。</p><p>1)若overflowToDisk=true,则会将Cache中多出的元素放入磁盘文件中。</p><p>2)若overflowToDisk=false,则根据memoryStoreEvictionPolicy策略替换Cache中原有的元素。</p><p><strong>Eternal</strong>：缓存中对象是否永久有效,即是否永驻内存,true时将忽略timeToIdleSeconds和timeToLiveSeconds。</p><p><strong>timeToIdleSeconds</strong>：缓存数据在失效前的允许闲置时间(单位:秒),仅当eternal=false时使用,默认值是0表示可闲置时间无穷大,此为可选属性即访问这个cache中元素的最大间隔时间,若超过这个时间没有访问此Cache中的某个元素,那么此元素将被从Cache中清除。</p><p><strong>timeToLiveSeconds</strong>：缓存数据在失效前的允许存活时间(单位:秒),仅当eternal=false时使用,默认值是0表示可存活时间无穷大，即Cache中的某元素从创建到清楚的生存时间,也就是说从创建开始计时,当超过这个时间时,此元素将从Cache中清除。</p><p><strong>overflowToDisk</strong>：内存不足时,是否启用磁盘缓存(即内存中对象数量达到maxElementsInMemory时,Ehcache会将对象写到磁盘中)，会根据标签中path值查找对应的属性值,写入磁盘的文件会放在path文件夹下,文件的名称是cache的名称,后缀名是data。</p><p><strong>diskPersistent</strong>：是否持久化磁盘缓存,当这个属性的值为true时,系统在初始化时会在磁盘中查找文件名为cache名称,后缀名为index的文件，这个文件中存放了已经持久化在磁盘中的cache的index,找到后会把cache加载到内存，要想把cache真正持久化到磁盘,写程序时注意执行net.sf.ehcache.Cache.put(Element  element)后要调用flush()方法。</p><p><strong>diskExpiryThreadIntervalSeconds</strong>：磁盘缓存的清理线程运行间隔,默认是120秒。</p><p><strong>diskSpoolBufferSizeMB</strong>：设置DiskStore（磁盘缓存）的缓存区大小,默认是30MB</p><p><strong>memoryStoreEvictionPolicy</strong>：内存存储与释放策略,即达到maxElementsInMemory限制时,Ehcache会根据指定策略清理内存，共有三种策略,分别为LRU(最近最少使用)、LFU(最常用的)、FIFO(先进先出)。</p><font color="red">在Spring的配置文件加入如下配置</font><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 开启Ehcache --&gt;</span><br><span class="line">&lt;cache:annotation-driven cache-manager=<span class="string">"cacheManager"</span>/&gt;  </span><br><span class="line">      </span><br><span class="line">&lt;bean id=<span class="string">"cacheManagerFactory"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.cache.ehcache.EhCacheManagerFactoryBean"</span>&gt; </span><br><span class="line">        &lt;property name=<span class="string">"configLocation"</span> value=<span class="string">"classpath:application/ehcache.xml"</span> /&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">      </span><br><span class="line">&lt;bean id=<span class="string">"cacheManager"</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.cache.ehcache.EhCacheCacheManager"</span>&gt;   </span><br><span class="line">        &lt;property name=<span class="string">"cacheManager"</span>  ref=<span class="string">"cacheManagerFactory"</span>/&gt;      </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><font color="red">在方法上使用注解</font><p><strong>@Cacheable</strong>主要针对方法配置，能够根据方法的请求参数对其结果进行缓存。</p><table><thead><tr><th>value</th><th>缓存的名称，在 spring 配置文件中定义，必须指定至少一个</th><th>例如：  @Cacheable(value=” menuCache”) 或者   @Cacheable(value={”cache1”,”cache2”}</th></tr></thead><tbody><tr><td>key</td><td>缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td>例如：  @Cacheable(value=” menuCache”, key=”#userName”)</td></tr><tr><td>condition</td><td>缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存</td><td>例如：  @Cacheable(value=” menuCache”, condition=”#userName.length()&gt;2”)</td></tr></tbody></table><p><strong>@CachePut</strong>主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用。</p><table><thead><tr><th>value</th><th>缓存的名称，在 spring 配置文件中定义，必须指定至少一个</th><th>例如：  @Cacheable(value=” menuCache”) 或者   @Cacheable(value={”cache1”,”cache2”}</th></tr></thead><tbody><tr><td>key</td><td>缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td>例如：  @Cacheable(value=”testcache”, key=”#userName”)</td></tr><tr><td>condition</td><td>缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存</td><td>例如：  @Cacheable(value=” menuCache”, condition=”#userName.length()&gt;2”)</td></tr></tbody></table><p><strong>@CachEvict</strong>主要针对方法配置，能够根据一定的条件对缓存进行清空。</p><table><thead><tr><th>value</th><th>缓存的名称，在 spring 配置文件中定义，必须指定至少一个</th><th style="text-align:left">例如：  @CachEvict(value=” menuCache”) 或者   @CachEvict(value={”cache1”,”cache2”}</th></tr></thead><tbody><tr><td>key</td><td>缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td style="text-align:left">例如：  @CachEvict(value=” menuCache”, key=”#userName”)</td></tr><tr><td>condition</td><td>缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才清空缓存</td><td style="text-align:left">例如：  @CachEvict(value=” menuCache”,  condition=”#userName.length()&gt;2”)</td></tr><tr><td>allEntries</td><td>是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存</td><td style="text-align:left">例如：  @CachEvict(value=” menuCache”, allEntries=true)</td></tr><tr><td>beforeInvocation</td><td>是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存</td><td style="text-align:left">例如：  @CachEvict(value=” menuCache”，beforeInvocation=true)</td></tr></tbody></table><hr>]]></content>
      
      <categories>
          
          <category> Ehcache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ehcache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring零碎知识收集</title>
      <link href="/2018/05/23/Spring%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E6%94%B6%E9%9B%86/"/>
      <url>/2018/05/23/Spring%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E6%94%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1526290577726.jpg" alt=""></p><p>这篇博客主要是对《Spring实战》以及日常工作时发现的一些有关Spring的零碎知识进行收集，内容可能会很多而且不一定全都有用，当作一本字典食用即可。</p><a id="more"></a><ul><li><p>@DateTimeFormat</p><ul><li>这个注解一般用在实体类的Date类型属性上，它可以将页面传递来的String类型日期转换为Date类型，但在4.0之前强依赖于joda-time.jar    ，必须要引入这个包才可以使用，4.0之后不再强依赖于这个jar包。</li></ul></li><li><p>&lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/fmt&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/fmt&quot;</a> prefix=”fmt” %&gt;</p><ul><li>这是一个jstl标签，其中有很多格式化的方法，比如格式化日期，数字等等，此处只做一个简单的记录，有需求可以直接百度，食用度不难。</li></ul></li><li><p>@Configuration </p><ul><li>这个注解相当于xml中的<code>&lt;beans&gt;&lt;beans/&gt;</code>标签，可以表明这个类是一个配置类，在SpringBoot中可能会用的比较多，而且在SpringBoot中不用开启注解扫描也可以直接使用。</li></ul></li><li><p>@ComponentScan</p><ul><li>这个注解会开启注解扫描，有属性值value，相当于base-package。一般在配置类上使用，若不配置这个属性，它会默认以配置类所处的包为base-package来扫描组件。</li></ul></li><li><p>@Component</p><ul><li>和@Controller，@Service这些用法一样，一般用于实例化实体类。</li></ul></li><li><p>@Named(“”)</p><ul><li>这个注解和上一个注解的用处一样，引号中的字符串可以当作bean的别名，@Component也可以通过这种方式来指定别名。</li></ul></li><li><p>@RunWith（SpringJUnit4ClassRunner.class）</p><ul><li>这个注解可以用在测试类上，测试时会自动加载Spring上下文。</li></ul></li><li><p>@ContextConfiguration（class=XXX.class）</p><ul><li>测试时与上一个注解搭配使用，这个注解可以指明哪一个类是配置类。</li></ul></li><li><p>@Inject</p><ul><li>这个注解和@Autowired一样都是用于bean的自动装配，它和@Named注解都来自于Java的依赖注入规范，大部分情况下这两个注解是可以互相替换的。</li></ul></li><li><p>@Bean（name=””）</p><ul><li>这个注解相当于XML配置文件中的<code>&lt;bean&gt;&lt;/bean&gt;</code>标签，用于方法上，它可以通知Spring该方法会返回一个对象，这个对像将要注册为Spring应用上下文的bean。用这种方法创建bean时，使我们有了在方法体中执行复杂逻辑的可能性，因为这完全是基于Java代码的，无论逻辑多复杂，只要最终返回一个实力就行。另外当一个方法已经使用了这个注解后，Spring会拦截所有对它的访问，如果它已经创建了一个bean,，就会直接返回这个bean，而不是每次都对其进行实际的调用</li></ul></li><li><p>Spring配置的三种主要方式</p><ul><li>自动化配置<ul><li>工作时一般都使用这种方法，目前接触的项目多数情况下还会搭配XML，使用方法一般都是在XML里开启组件扫描，同时配置数据库，事务，拦截器等等，然后在代码中的使用@Controller，@Service，@Autowired这些注解。</li><li>虽然自动化配置很方便，但有些时候必须要显示的进行一些配置，比如在使用第三方的一些组件时，我们就没有办法去给它添加注解，除了上面所说的搭配XML，我们还可以搭配JavaConfig（基于Java的显示配置），使用这种方法时我们会创建一个类来取代XML，当我们为这个类加上@Configuration注解时，它就会被Spring认为是一个配置类，同时Spring也提供了大量的注解来对应XML中的标签，以便我能够实现所有XML中能够实现的功能，而且这种方法比XML更加强大。</li></ul></li><li>基于Java的显示配置<ul><li>正如上面所说的，我们在使用这种方法时可以创建一个类来取代XML，通过@Configuration来申明它是一个配置类，通过@ComponentScan来开启组件扫描，通过@Bean来创建实例等等，可能还有其它许多注解，但此处只做简单描述，未来可能在SpringBoot的学习中详细记录这种方式。</li></ul></li><li>基于XML的显示配置<ul><li>最原始的方法，见过无数次的<code>&lt;bean&gt;&lt;bean/&gt;</code>标签，<code>&lt;property/&gt;</code>标签等等，百度一抓一大把，基本也没什么可说的了。</li></ul></li></ul></li><li><p>@Import（XXX.calss）</p><ul><li>这个注解相当与XML中的<code>&lt;import&gt;</code>标签，在4.2前只能导入配置类，在4.2之后，@Import注解支持导入普通的Java类,并将其声明成一个bean ，当一个JavaConfig配置的内容过多，我们可以将其拆分为两个或更多的JavaConfig，通过使用这个注解将多个JavaConfig进行统一。同时也可以使用@Import（｛XXX.class,XXX.class｝）一次引入多个JavaConfig。</li></ul></li><li><p>@ImportResource(“classpath:”)</p><ul><li>这个注解和上一个注解的用处一样，是用来引入XML配置文件的</li></ul></li><li><p>条件化的bean</p><ul><li>当我们希望一个bean只有在满足一定的条件下时才会被创建，可以在方法上使用@Conditional（XXX.class）注解，XXX是一个我们自定义的类，它必须实现Condition接口，并且重写matches()方法，当这个方法返回true时，这个bean就会被创建，如果返回false，则不会创建。</li></ul></li><li><p>@Qualifier(“”)</p><ul><li>这个注解可以配合@Autowired或@Inject使用，这个注解应用于有一个以上的bean可以匹配自动装配，比如一个接口有三个实现类，在自动装配时使用的参数类型是接口而不是实现类，这时Spring就会无法分辨你想要将哪一个子类注入，便会抛出异常。@Qualifier(“”)注解可以通过在””中指明限定符（默认情况下使用bean的id即可），从而准确的注入我们想要的bean。我们也可以不使用bean的id，自己来定义限定符，将@Qualifier(“”)和@Component，@Bean这类用于实例化的一起使用，””中的内容就是自定义的限定符</li></ul></li><li><p>@Scope()</p><ul><li>这个注解是用来声明bean的作用域的，在Spring中默认的作用域为Singleton，我们可以通过value属性将其改变为Prototype(多例)，Session(会话)，Request(请求)</li><li>proxyMode属性：这个属性可以解决将Session或Request作用域的bean注入到单例bean中所遇到的问题。当向一个单例的bean注入Session范围的或Request范围的bean时，它们此时并没有创建，直到一个用户发起了一个会话或进行了一次请求，它们才会被创建。<ul><li>以电子商务中的购物车系统为例，ShoppingCart实例的作用范围都是Session，而处理业务的ShoppingCartService都是单例的，当我们向ShoppingCartService中注入一个ShoppingCart时，这个ShoppingCart可能还没有被创建，直到一个用户发起了一次会话，ShoppingCart才会被创建，另外在向ShoppingCartService注入ShoppingCart时，我们并不希望注入的是一个固定的ShoppingCart实例，我们希望的时当ShoppingCartService处理购物车功能时，它所使用的ShoppingCart正好是当前会话的对应的那一个。所以Spring会注入一个ShoppingCart bean的代理，这个代理会暴露与ShoppingCart相同的方法，所以ShoppingService会认为它就是一个ShoppingsCart，但是在调用ShoppingCart中的方法时，代理会对其进行懒解析并将调用委托给会话作用域内真正的ShoppingCart bean。这个属性有两个常用的值，以ShoppingCart为例，假如ShoppingCart是一个接口，那么proxyMode的值是ScopedProxyMode.INTERFACES，如果ShoppingCart是一个类，那么proxyMode的值是ScopedProxyMode.TARGET_CLASS</li></ul></li><li><code>&lt;aop:scoped-proxy&gt;</code>：这个标签就是XML中proxyMode的用法，默认使用ScopedProxyMode.TARGET_CLASS，也可以将proxy-target-class设为false，将其变成基于接口的代理，需要注意的是使用这个注解需要开启aop命名空间。</li></ul></li><li><p>Spring中关于AOP的一些注解</p><ul><li>@EnableAspectJAutoProxy：这个注解可以用在配置类上，作用与组件扫描类似，开启之后可以识别@Aspect注解，如果是在XML中，可以使用Spring aop命名空间中的<code>&lt;aop:aspectj-autoproxy&gt;</code></li><li>@Aspect：这个注解可以标明一个类是切面。</li><li>@Before()：应用这个注解的方法会在目标方法调用之<font color="red">前</font>执行。</li><li>@After()：应用这个注解的方法会在目标方法调用之<font color="red">后</font>执行。</li><li>@AfterReturning()：应用这个注解的方法会在目标方法<font color="red">返回后</font>执行。</li><li>@AfterThrowing()：应用这个注解的方法会在目标方法<font color="red">抛出异常后</font>执行。</li><li>@Around()：应用这个注解的方法会在目标方法<font color="red">执行之前与执行之后</font>执行。</li><li>@Pointcut()：这个注解能够在切面内定义可以复用的切点。</li></ul></li><li><p>如果使用基于Java的配置方式，在配置web.xml时需要注意两点</p><ul><li><p>原先指定xml的路径要变成JavaConfig的路径</p></li><li><p>要额外在web.xml中声明使用Java配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">&lt;param-name&gt;contextClass&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;</span><br><span class="line">org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line"></span><br><span class="line">在servlet标签中使用</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;contextClass&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;</span><br><span class="line">org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p>​    </p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring实战第四版</title>
      <link href="/2018/05/12/Spring%E5%AE%9E%E6%88%98%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
      <url>/2018/05/12/Spring%E5%AE%9E%E6%88%98%E7%AC%AC%E5%9B%9B%E7%89%88/</url>
      <content type="html"><![CDATA[<p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1526290577726.jpg" alt=""></p><p>写这篇博客是因为发现虽然平时工作中经常和Spring打交道。但是重复的造车轮工作并没有帮助我更好的去理解它，所以开始研究《Spring实战第四版》这本书，以便对Spring进行更近一步的学习。</p><a id="more"></a><h2 id="Spring基本理念"><a href="#Spring基本理念" class="headerlink" title="Spring基本理念"></a>Spring基本理念</h2><p>Spring最基本的理念就是简化代码开发，再抛开一切外壳之后，最终的基本策略都会回归到以下四点</p><ol><li>基于POJO的轻量级和最小侵入性编程</li><li>通过依赖注入和面向接口实现松耦合</li><li>基于切面和惯例进行声明式编程</li><li>通过切面和模板减少样板式代码</li></ol><h2 id="DI（依赖注入）"><a href="#DI（依赖注入）" class="headerlink" title="DI（依赖注入）"></a>DI（依赖注入）</h2><p>我觉得可以从三个问题来理解一下DI</p><ol><li>什么是DI？</li><li>DI能够做什么？</li><li>它是如何做到的？</li></ol><p>对于第一第二个问题，比较理论化一点，简单描述一下：DI发展到如今，已经变成了一种编程技巧和程序设计理念，它能够极大的降低程序的耦合性，还可以使代码的测试变得简单。</p><p>（关于耦合：这是一个具有两面性的东西，过高的耦合性会使代码难于测试，理解以及复用，同时可能会出现连锁式的BUG，修复好一个，又出现一个或多个新BUG，但完全没有耦合性的代码也没啥用，    想要完成有实际意义的功能，代码之间必须有适当的交互过程）</p><p>至于对于第三个问题可能是需要重点关注的，首先定一个大的基调：依赖注入能够降低高耦合性的问题是因为<font color="red">它不再让调用者来主动创建被调用者的实例，而是将其交给Spring来执行</font></p><h2 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP(面向切面编程)"></a>AOP(面向切面编程)</h2><p>在软件开发中，同一个功能如果散布于应用中多处，我们可以称其为横切关注点。从概念上来说我们应该将其与业务逻辑分离（但是往往会直接嵌入到业务逻辑之中）。AOP要做的就是把这些横切关注点与业务逻辑相分离。</p><p>DI能够实现应用对象之间的解耦，而AOP可以实现横切关注点与它们所影响的对象之间的解耦</p><p>关于AOP术语的理解：通知包含了用于多个应用对象的横切行为，连接点是程序中可以应用通知的所有点，切点定义了通知被应用的具体位置（也可以理解为切点定义了哪些连接点会得到通知），切点与通知的结合称为切面，将切面应用到目标对象并创建新的代理对象叫做织入，在目标对像的生命周期里有多个点可以进行织入</p><ol><li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器，它可以在目标类被引入引用之前增强该目标类的字节码。AspectJ 5的加载时织入就支持以这种方式织入切面</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态的创建一个代理对象。Spring AOP就是以这种方式织入切面的</li></ol><p>关于Spring AOP框架的一些关键知识</p><ol><li>Spring的通知是由Java编写的</li><li>Spring在运行时通知对象：代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean，当代理拦截到方法调用时，在调用目标bean的方法之前，会执行切面逻辑。</li><li>Spring只支持方法级别的连接点</li></ol><p>##</p><hr>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简单写点东西撑撑首页</title>
      <link href="/2018/05/11/%E7%AE%80%E5%8D%95%E5%86%99%E7%82%B9%E4%B8%9C%E8%A5%BF%E6%92%91%E6%92%91%E9%A6%96%E9%A1%B5/"/>
      <url>/2018/05/11/%E7%AE%80%E5%8D%95%E5%86%99%E7%82%B9%E4%B8%9C%E8%A5%BF%E6%92%91%E6%92%91%E9%A6%96%E9%A1%B5/</url>
      <content type="html"><![CDATA[<h3 id="来自博主的碎碎念"><a href="#来自博主的碎碎念" class="headerlink" title="来自博主的碎碎念"></a><center>来自博主的碎碎念<center></center></center></h3><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528194439532.jpg" alt=""></p><a id="more"></a><blockquote class="blockquote-center"><p>嗯，闲鱼玩家终于也有的自己的博客了</p><p>激动ING</p><p>虽然布局很一般，但是会慢慢优化的（才怪）</p><p>毕竟博主是一个专业的前端工程师（手动滑稽）</p><p>CSS什么的根本不（wan）在（quan）话（bu）下（dong）</p><p>凭借我出色的审美</p><p>一定<del>不</del>会好好考虑如何搭配颜色，合理布局的</p><p>相信假以时日这个博客必定能够红红火火恍恍惚惚哈哈哈哈</p><hr><p>来自没有良心的博主(大英雄，你np满了)</p></blockquote>]]></content>
      
      <categories>
          
          <category> 即兴乱写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BB </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
