<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>在IDEA中使用Git</title>
      <link href="/2018/07/18/%E5%9C%A8IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Git/"/>
      <url>/2018/07/18/%E5%9C%A8IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Git/</url>
      <content type="html"><![CDATA[<p>本篇博客转载自张扎瓦的博客，本人只在此处充当一下搬运工，大家可以点击<a href="https://www.zhangjava.com/IntelliJ-IDEA-%E4%BD%BF%E7%94%A8git/#more" target="_blank" rel="noopener">神奇传送门</a>前往原文博客的说。</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528787244937.jpg" alt=""></p><a id="more"></a><h2 id="IDEA中git的配置"><a href="#IDEA中git的配置" class="headerlink" title="IDEA中git的配置"></a>IDEA中git的配置</h2><p>使用Ctrl+Alt+S打开设置 ：</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1531923844289.png" alt=""></p><p>如图所示进行配置，配置完场后点击<code>Test</code>按钮，如果弹出版本号表示配置成功。 </p><h2 id="项目中使用Git"><a href="#项目中使用Git" class="headerlink" title="项目中使用Git"></a>项目中使用Git</h2><h4 id="检出项目"><a href="#检出项目" class="headerlink" title="检出项目"></a>检出项目</h4><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1531923939817.png" alt=""></p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1531923974247.png" alt=""></p><p>填写完地址后，点击<code>Clone</code>就可以检出项目了。 </p><h4 id="为项目添加版本控制"><a href="#为项目添加版本控制" class="headerlink" title="为项目添加版本控制"></a>为项目添加版本控制</h4><p>如图所示，为项目创建一个本地git版本库 ：</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1531924187460.png" alt=""></p><p>选择当前项目所在的文件夹：</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1531924102819.png" alt=""></p><p>项目右键，将项目添加到版本控制中 ：</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1531924318007.png" alt=""></p><p>提交项目到本地仓库：</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1531924342201.png" alt=""></p><p>填写提交说明，点击提交 ：</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1531924450077.png" alt=""></p><p>连接到远程仓库 ：</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1531924450342.png" alt=""></p><p>设置远程仓库位置：</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1531924568540.png" alt=""></p><p>推送至远程仓库：</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1531924568696.png" alt=""></p><hr>]]></content>
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot（番外）：使用lombok简化实体</title>
      <link href="/2018/07/18/SpringBoot%EF%BC%88%E7%95%AA%E5%A4%96%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8lombok%E7%AE%80%E5%8C%96%E5%AE%9E%E4%BD%93/"/>
      <url>/2018/07/18/SpringBoot%EF%BC%88%E7%95%AA%E5%A4%96%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8lombok%E7%AE%80%E5%8C%96%E5%AE%9E%E4%BD%93/</url>
      <content type="html"><![CDATA[<p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528342168360.jpg" alt=""></p><a id="more"></a><h2 id="为什么使用lombok"><a href="#为什么使用lombok" class="headerlink" title="为什么使用lombok"></a>为什么使用lombok</h2><p>使用lombok可以帮我们减少很多模板化的代码，例如实体类的getter、setter方法。但需要注意的是，由于省略了许多代码，采用了注解代替，可能会使阅读性降低，另外使用lombok需要在IDEA中安装一个插件，如果没有这个插件可能会出现很多报红，当一个没有使用过lombok的同行来看你写的代码可能会感觉有些疑惑。关于这一点小组内部进行好技术统一其实也不是什么大问题。</p><p>##如何使用lombok</p><p>####在IDEA中安装lombok插件</p><p>打开IDEA的Setting –&gt; 选择Plugins选项 –&gt; 选择Browse repositories –&gt; 搜索lombok –&gt; 点击安装 –&gt; 安装完成重启IDEA –&gt; 安装成功 </p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>在pom文件中添加依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.16.18&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><p>关于lombok提供的注解可以参考<a href="https://projectlombok.org/features/all" target="_blank" rel="noopener">lombok帮助文档</a>，此处对常用的注解做一些简单的描述</p><ul><li><p><strong>@Getter和@Setter</strong>：这个注解可以用在类上或属性上，可以创建出getter和setter方法，同时还会创建一个无参构造。</p></li><li><p><strong>@NonNull</strong>：该注解使用在<strong>属性</strong>上，该注解用于属的非空检查，当放在setter方法的字段上，将生成一个空检查，如果为空，则抛出<code>NullPointerException</code>，该注解会默认生成一个无参构造。</p></li><li><p><strong>@toString</strong>：该注解用在类上，会自动生成<code>toString</code>方法。</p><ul><li>如果需要可以通过注释参数<code>includeFieldNames</code>来控制输出中是否包含的属性名称。   </li><li>可以通过<code>exclude</code>参数中包含字段名称，可以从生成的方法中排除特定字段。</li><li>可以通过<code>callSuper</code>参数输出父类字段，前提是父类也有<code>toString</code>方法，不然会打印出地址值。 </li></ul></li><li><p>@<strong>EqualsAndHashCode</strong>：这个注解可以用在类上，会生成<code>equals</code>方法和<code>hashCode</code>方法，当存在继承关系需要设置<code>callSuper</code>参数为<code>true</code> 。</p></li><li><p><strong>NoArgsConstructor</strong>：这个注解可以用在类上，可以提供一个无参构造。</p></li><li><p><strong>@AllArgsConstructor</strong>：这个注解可以用在类上，可以提供一个全参构造，默认不提供无参构造。</p></li><li><p><strong>@Data</strong>：这个注解用在类上，会创建getter、setter、equals、canEqual、hashCode、toString方法 。</p></li><li><p><strong>@Builder</strong>：可以开启建造者模式，创建对象的时候不再需要单独调用setter方法。</p><ul><li>将这个注解与@Data一起使用可以减少很多代码，但这样使用时需要注意一点，我们需要手动创建一个无参构造，并在上面加上@Tolerate注解，不然会报错。</li></ul></li><li><p>Log：log的注解有很多选择，具体如下，可以根据不同的日志系统选择需要的注解</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@CommonsLog</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);</span><br><span class="line"><span class="comment">//@JBossLog</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class);</span><br><span class="line"><span class="comment">//@Log</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());</span><br><span class="line"><span class="comment">//@Log4j</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class);</span><br><span class="line"><span class="comment">//@Log4j2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);</span><br><span class="line"><span class="comment">//@Slf4j</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);</span><br><span class="line"><span class="comment">//@XSlf4j</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式：简单工厂</title>
      <link href="/2018/07/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/"/>
      <url>/2018/07/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/</url>
      <content type="html"><![CDATA[<p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1531295882995.png" alt=""></p><p>此篇博客参考书籍《研磨设计模式》,相比GoF的设计模式，此书更加通俗易懂，适合作为设计模式的入门书籍。</p><a id="more"></a><h2 id="场景问题"><a href="#场景问题" class="headerlink" title="场景问题"></a>场景问题</h2><p>在Java应用开发中，我们应该遵守<font color="red">“面向接口编程”</font>的原则，而接口的思想浓缩成一句话就是<font color="red">“封装隔离”</font>，此处的封装指的是<font color="red">“对被隔离体的行为的封装”</font>，而隔离指的是<font color="red">外部的调用和内部实现</font>，外部的调用只能通过接口来进行调用，而不知道内部的具体实现。</p><p>在我们学习Java的基础知识时，有时会遇到如下类型的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Impl</span> <span class="keyword">implements</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"let's paly ♂ a ♂ game："</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端：测试使用Api接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Api api = <span class="keyword">new</span> Impl();</span><br><span class="line">        api.test(<span class="string">"哲学♂ 冲浪板！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端中有这样一句代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Api api = <span class="keyword">new</span> Impl()</span><br></pre></td></tr></table></figure><p>你会发现客户端在调用时，它不但知道了接口，同时还知道了具体的实现是Impl，然而接口的思想是隔离封装，客户端不应该知道实现类是Impl，但是如果将<code>new Impl()</code>去掉，Api的接口对象又无法获得。</p><p>如果将这个问题描述一下就是：在Java编程中，需要只知接口不知实现的情况，该怎么办？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>用来解决上述问题的一个合理解决方案就是简单工厂，关于简单工厂的定义是这样的：<font color="red">提供一个创建对象实例的功能，而无需关心其具体实现。被创建实例的类型可以是接口，抽象类，也可以是具体的类<font></font></font></p><h4 id="解决问题的思路"><a href="#解决问题的思路" class="headerlink" title="解决问题的思路"></a>解决问题的思路</h4><p>虽然不能让模块外部知道模块内部的具体实现，但是模块内部是可以知道的，那么干脆在模块内部新建一个类，在这个类里面来创建接口，然后把创建好的接口返回给客户端。</p><h4 id="使用简单工厂重写示例"><a href="#使用简单工厂重写示例" class="headerlink" title="使用简单工厂重写示例"></a>使用简单工厂重写示例</h4><p>下面我们用简单工厂的模式重写实现一下刚才的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Impl</span> <span class="keyword">implements</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"let's paly ♂ a ♂ game："</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Factory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Api <span class="title">creatApi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Impl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端：测试使用Api接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Api api = Factory.createApi();</span><br><span class="line">        api.test(<span class="string">"哲学♂ 冲浪板！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式讲解"><a href="#模式讲解" class="headerlink" title="模式讲解"></a>模式讲解</h2><h4 id="认识简单工厂设计模式"><a href="#认识简单工厂设计模式" class="headerlink" title="认识简单工厂设计模式"></a>认识简单工厂设计模式</h4><p>简单工厂的功能就是创建对象，我们在使用简单工厂的时候，通常不用创建简单工厂类的实例，而是将创建对象的方法变为静态方法，所以简单工厂又可以称为静态工厂。如果想要防止客户端无谓的创造简单工厂实例。我们还可以将构造方法私有化。</p><p>虽然从理论上讲，简单工厂可以创建任何对象，但我们再使用时，尽量将创建的范围独立成一个组建或者模块级别，否则这个工厂类会显得职责不明，有点大杂烩的感觉。</p><h4 id="简单工厂的优点和不足"><a href="#简单工厂的优点和不足" class="headerlink" title="简单工厂的优点和不足"></a>简单工厂的优点和不足</h4><p>优点</p><p>​    帮助封装，去除了客户端与具体实现类的依赖，封装了对象的创建过程。</p><p>不足</p><p>​    工厂类中包含了多个实例创建的逻辑，一旦工厂出现问题，会影响到所有实例的创建。</p><p>​    如果想要添加一个新的实例让简单工厂来创建，就必须去修改简单工厂的创建方法，不太符合”开放-关闭”（对扩展开放，对修改关闭）原则。</p><h4 id="增强扩展性"><a href="#增强扩展性" class="headerlink" title="增强扩展性"></a>增强扩展性</h4><p>利用反射技术可以增强简单工厂的扩展性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Impl</span> <span class="keyword">implements</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"let's paly ♂ a ♂ game："</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用反射技术实现创建对象的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Factory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Api <span class="title">creatApi</span><span class="params">(Class c)</span></span>&#123;</span><br><span class="line">        Api api = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            api = (Api) Class.forName(c.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"不支持抽象类或接口"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"没有足够权限，即不能访问私有对象"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"类不存在"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> api;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Api api = Factory.createApi(Impl.class);</span><br><span class="line">        api.test(<span class="string">"哲学♂ 冲浪板！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单工厂在JDK中的应用"><a href="#简单工厂在JDK中的应用" class="headerlink" title="简单工厂在JDK中的应用"></a>简单工厂在JDK中的应用</h4><p>在JDK中最典型的简单工厂的应用就是JDBC</p><p>将关系型数据库认为是抽象产品，将MySQL，Oracle认为是具体产品，</p><p>DriverManager是工厂类</p><p>应用程序通过JDBC接口使用关系型数据库,不需关心使用哪种数据库</p><p>直接使用DriverManager的静态方法去得到该数据库的Connection即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.brave.simplefactory.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单工厂在JDK中的使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1/student"</span>);</span><br><span class="line">            PreparedStatement ps = conn.prepareStatement(<span class="string">"select * from mysql.test"</span>);</span><br><span class="line">            ps.execute();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Execute query failed "</span> + ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Load mysql driver failed "</span> + e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>搭建git服务器</title>
      <link href="/2018/06/25/%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/06/25/%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>本篇博客转载自张扎瓦的博客，本人只在此处充当一下搬运工，大家可以点击<a href="https://www.zhangjava.com/%E4%BD%BF%E7%94%A8GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">神奇传送门</a>前往原文博客的说。</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528787244937.jpg" alt=""></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    git可以说是目前使用最广泛的版本控制系统了，GitHub是基于git的免费的代码托管网站，有人说，既然都是免费的了，直接用不就好了吗，干嘛还要费劲自己搭建一个服务。我想说的是，GitHub虽然是免费的，但是有一点很重要，那就是私有性。公司内部的项目通常都是要保密的。虽然GitHub可以选择仓库私有，但那是要收费的。综上所述，还是在自己私有的服务器上搭建git服务比较合适。</p><p>  本次演示使用VMware虚拟机，系统镜像CentOS 6.9 x64，root账户进行安装操作。</p><h2 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>使用yum查询当前是否有可安装的git版本 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum info git</span><br></pre></td></tr></table></figure><p>使用yum安装git</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y git</span><br></pre></td></tr></table></figure><p>检查是否安装成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># git version</span><br><span class="line">git version <span class="number">1.7</span>.1</span><br></pre></td></tr></table></figure><h3 id="创建git运行用户"><a href="#创建git运行用户" class="headerlink" title="创建git运行用户"></a>创建git运行用户</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># adduser git</span><br></pre></td></tr></table></figure><p>在当前Linux系统中创建了一个新的用户<code>git</code>。</p><p>执行完以上命令后，会在<code>/home</code>生成一个<code>git</code>文件夹。我们cd到home目录查看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cd /home/git</span><br><span class="line"># ls -a</span><br><span class="line">.  ..  .bash_logout  .bash_profile  .bashrc  .gnome2  .mozilla</span><br></pre></td></tr></table></figure><h3 id="禁止git用户shell登陆"><a href="#禁止git用户shell登陆" class="headerlink" title="禁止git用户shell登陆"></a>禁止git用户shell登陆</h3><p>创建git用户是为了访问服务器的git仓库，为了安全起见，将git用户禁止shell登录。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/passwd</span><br></pre></td></tr></table></figure><p>找到类似下面的一句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:501:501::/home/git:/bin/bash</span><br></pre></td></tr></table></figure><p>将其改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:<span class="number">501</span>:<span class="number">501</span>::/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><p>保存即可。</p><h3 id="创建ssh证书登录"><a href="#创建ssh证书登录" class="headerlink" title="创建ssh证书登录"></a>创建ssh证书登录</h3><p>在<code>/home/git</code>文件夹下，创建一个新文件夹<code>.ssh</code>，并新建一个文件<code>authorized_keys</code>，这个<code>authorized_keys</code>文件用来存放我们的git公钥。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># mkdir .ssh</span><br><span class="line"># cd .ssh</span><br><span class="line"># touch authorized_keys</span><br><span class="line"># ls</span><br><span class="line">authorized_keys</span><br></pre></td></tr></table></figure><p>收集团队中其他人的git公钥，复制后添加到<code>authorized_keys</code>文件中。git公钥一般存放在<code>C:\Users\xxx\.ssh\id_rsa.pub</code>中。如果你的电脑上没有，需要安装git客户端，并生成git公钥。关于此部分，我的另一篇博客<a href="https://www.zhangjava.com/%E4%BD%BF%E7%94%A8GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">使用GitHub-Pages-Hexo-搭建博客</a>中有所介绍，此处不再细讲。 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim authorized_keys</span><br></pre></td></tr></table></figure><p>注意：粘贴公钥时，注意空格。公钥一行一个。 </p><h3 id="初始化git仓库"><a href="#初始化git仓库" class="headerlink" title="初始化git仓库"></a>初始化git仓库</h3><p>创建一个仓库目录，我放在<code>/home</code>下面 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mkdir gitrepo</span><br><span class="line"># ls</span><br><span class="line">git  gitrepo</span><br></pre></td></tr></table></figure><p>初始化git仓库，假设项目名叫<code>test</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cd gitrepo/</span><br><span class="line"># git init --bare test.git</span><br><span class="line">Initialized empty Git repository in /home/gitrepo/test.git/</span><br></pre></td></tr></table></figure><p>执行完命令后，会在<code>gitrepo</code>下生成<code>test.git</code>目录 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls</span><br><span class="line">test.git</span><br></pre></td></tr></table></figure><p>修改仓库的归属权限，否则无法访问git仓库</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chown -R git:git test.git/</span><br></pre></td></tr></table></figure><h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">λ git clone git@<span class="number">192.168</span>.213.130:/home/gitrepo/test.git</span><br><span class="line">Cloning into <span class="string">'test'</span>...</span><br><span class="line">key_load_public: invalid format</span><br><span class="line">warning: You appear to have cloned an empty repository</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用GitHub Pages + Hexo搭建博客</title>
      <link href="/2018/06/12/%E4%BD%BF%E7%94%A8GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/06/12/%E4%BD%BF%E7%94%A8GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>本篇博客转载自张扎瓦的博客，本人只在此处充当一下搬运工，大家可以点击<a href="https://www.zhangjava.com/%E4%BD%BF%E7%94%A8GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">神奇传送门</a>前往原文博客的说。</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528787244937.jpg" alt=""></p><a id="more"></a><h2 id="GitHub部分"><a href="#GitHub部分" class="headerlink" title="GitHub部分"></a>GitHub部分</h2><h3 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h3><p>Git repository用于存放博客内容</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528789143663.png" alt=""></p><p>点击之后会跳转到创建仓库页面</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528789304530.png" alt=""></p><p>私有仓库收费，公共仓库免费，可以根据自己的情况选择。</p><h3 id="仓库设置"><a href="#仓库设置" class="headerlink" title="仓库设置"></a>仓库设置</h3><p>仓库创建成功后，进入仓库主页</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528789570552.png" alt=""></p><p>点击Settings进入仓库设置</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528789738824.png" alt=""></p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528789739042.png" alt=""></p><p>如果创建时仓库的名字是<code>xxx.github.io</code>，则以上的选项默认是选中的。</p><p>至此，创建仓库就完成了，此时打开浏览器，输入<code>xxx(自己的仓库名).github.io</code>就能访问自己的主页了。</p><h3 id="安装Git客户端"><a href="#安装Git客户端" class="headerlink" title="安装Git客户端"></a>安装Git客户端</h3><p>仓库创建完成之后，需要安装Git客户端与Git仓库进行链接，方便我们在本地提交博客。</p><p>根据自己的操作系统，<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载git客户端</a>，完成安装。</p><h4 id="设置Git环境变量"><a href="#设置Git环境变量" class="headerlink" title="设置Git环境变量"></a>设置Git环境变量</h4><p>打开git的安装目录，并复制安装路径。</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528790576948.png" alt=""></p><p>桌面上找到我的电脑 – &gt; 右键 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量 –&gt; 系统变量  –&gt; Path 。</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1529654220481.png" alt=""></p><p>新建变量值，将刚刚复制的路径填进去，并在末尾加上<code>\cmd</code>，保存即可 。</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1529654291425.png" alt=""></p><p>测试环境变量是否配置成功，打开命令行输入 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br></pre></td></tr></table></figure><p>如果输出版本号，表示配置成功。</p><h4 id="设置用户名和邮箱"><a href="#设置用户名和邮箱" class="headerlink" title="设置用户名和邮箱"></a>设置用户名和邮箱</h4><p>点击鼠标右键，选择<code>Git Bash Here</code>，打开git bash客户端。输入下面的命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"lishuai"</span></span><br><span class="line">git config --global user.email<span class="string">"xxxx@xxx.com"</span></span><br></pre></td></tr></table></figure><h4 id="生成ssh密钥"><a href="#生成ssh密钥" class="headerlink" title="生成ssh密钥"></a>生成ssh密钥</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"xxxx@xxx.com"</span></span><br></pre></td></tr></table></figure><p>连续回车即可。</p><h4 id="设置GitHub公钥"><a href="#设置GitHub公钥" class="headerlink" title="设置GitHub公钥"></a>设置GitHub公钥</h4><p>打开目录<code>C:\Users\你自己的用户名\.ssh</code>下，会有两个文件 <code>id_rsa</code>(私钥) <code>id_rsa.pub</code>(公钥) ，使用文本编辑器打开<code>id_rsa.pub</code>，复制里面的内容，登录GitHub，进入个人设置中心。 </p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1529655305181.png" alt=""></p><p>开始设置ssh</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1529655377645.png" alt=""></p><p>新建ssh key</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1529655424081.png" alt=""></p><p>填入公钥</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1529656303890.png" alt=""></p><p>点击 <code>Add SSH key</code>就可以了。 </p><p>在本地测试链接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git<span class="meta">@github</span>.com</span><br></pre></td></tr></table></figure><p>当输出以下内容是，表示连接成功。</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1529656809692.png" alt=""></p><h2 id="Hexo部分"><a href="#Hexo部分" class="headerlink" title="Hexo部分"></a>Hexo部分</h2><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p>根据做自己的操作系统平台，<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">下载nodejs</a>，并安装。</p><blockquote><p>nodejs的环境变量在nodejs安装好后，会自己添加到环境变量中，一般不需要设置。</p></blockquote><h3 id="手动设置环境变量"><a href="#手动设置环境变量" class="headerlink" title="手动设置环境变量"></a>手动设置环境变量</h3><p>安装完成后在命令中输入如下命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --version</span><br></pre></td></tr></table></figure><p>如果输出版本号，则表示配置成功。如果没有输出，我们可以自己手动的配置一下环境变量。</p><p>配置过程与git的环境变量一致，只不过不需要添加cmd。</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>使用npm安装Hexo,npm是node自带的宝以来管理工具，类似于Centos中的yum。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>具体细节可以浏览<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo官方文档</a>，写的十分详细。</p><h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><p>命令行中输入如下命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init 自定义的文件夹</span><br><span class="line">cd 自定义的文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定的文件夹目录如下：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; .</span><br><span class="line">&gt; ├── _config.yml#博客的全局配置文件</span><br><span class="line">&gt; ├── package.json#包含了应用程序的信息</span><br><span class="line">&gt; ├── scaffolds#模板文件夹</span><br><span class="line">&gt; ├── source#用户资源文件夹</span><br><span class="line">&gt; |   ├── _drafts#草稿箱</span><br><span class="line">&gt; |   └── _posts#写的文章放到这里</span><br><span class="line">&gt; └── themes#主题文件夹</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>_config.yml</code>文件详解 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: Hexo#网站标题</span><br><span class="line">subtitle:#网站副标题</span><br><span class="line">description:#网站描述</span><br><span class="line">keywords:#关键字</span><br><span class="line">author: John Doe#网站作者</span><br><span class="line">language:#网站所使用的语言 中文使用 zh-Hans 防止乱码</span><br><span class="line">timezone:#网站时区  Asia/Shanghai</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span><br><span class="line">url: http:<span class="comment">//yoursite.com#网址</span></span><br><span class="line">root: /#网站根目录</span><br><span class="line">permalink: :year/:month/:day/:title/#文章的 永久链接 格式</span><br><span class="line">permalink_defaults:#永久链接中各部分的默认值</span><br><span class="line"># 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 # http://yoursite.com/blog 并把 root 设为 /blog/。</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source#资源文件夹，这个文件夹用来存放内容。</span><br><span class="line">public_dir: public#公共文件夹，这个文件夹用于存放生成的站点文件</span><br><span class="line">tag_dir: tags#标签文件夹</span><br><span class="line">archive_dir: archives#归档文件夹</span><br><span class="line">category_dir: categories#分类文件夹</span><br><span class="line">code_dir: downloads/code#Include code 文件夹</span><br><span class="line">i18n_dir: :lang#国际化（i18n）文件夹</span><br><span class="line">skip_render:#跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md#新文章的文件名称</span><br><span class="line">default_layout: post#预设布局</span><br><span class="line">titlecase: false#把标题转换为 title case</span><br><span class="line">external_link: true#在新标签中打开链接</span><br><span class="line">filename_case: 0#把文件名称转换为 (1) 小写或 (2) 大写</span><br><span class="line">render_drafts: false#显示草稿</span><br><span class="line">post_asset_folder: false#启动 Asset 文件夹</span><br><span class="line">relative_link: false#把链接改为与根目录的相对位址</span><br><span class="line">future: true#显示未来的文章</span><br><span class="line">highlight:#代码块的设置</span><br><span class="line">  enable: true#是否开启代码块支持</span><br><span class="line">  line_number: true#显示行号</span><br><span class="line">  auto_detect: <span class="keyword">false</span></span><br><span class="line">  tab_replace:#设置用什么字符替代Tab，如tab_replace: aaa，在代码中将输入tab的地方替换为aaa</span><br><span class="line">  </span><br><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = '')</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: <span class="string">''</span></span><br><span class="line">  per_page: <span class="number">10</span></span><br><span class="line">  order_by: -date</span><br><span class="line">  </span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized#默认分类</span><br><span class="line">category_map:#分类别名</span><br><span class="line">tag_map:#标签别名</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD#日期格式</span><br><span class="line">time_format: HH:mm:ss#时间格式</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10#每页显示的文章条数</span><br><span class="line">pagination_dir: page#分页目录</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: landscape#当前所使用的主题名</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:#部署部分设置</span><br><span class="line">  type:#部署类型</span><br></pre></td></tr></table></figure><p>根据需要更改的配置文件，进行个性化配置。</p><h3 id="启动Hexo服务"><a href="#启动Hexo服务" class="headerlink" title="启动Hexo服务"></a>启动Hexo服务</h3><p>初始化完成后，就可以启动Hexo服务了，进入博客目录，执行以下命令，即可启动服务 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g#生成静态文件</span><br><span class="line">hexo s#启动hexo服务</span><br></pre></td></tr></table></figure><p>打开浏览器，输入<code>localhost:4000</code></p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1529658172532.png" alt=""></p><h3 id="Hexo基本命令"><a href="#Hexo基本命令" class="headerlink" title="Hexo基本命令"></a>Hexo基本命令</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo generate#生成静态文件，可以简写为 hexo g</span><br><span class="line">hexo clean#清除生成的静态文件</span><br><span class="line">hexo server#启动hexo服务进行预览，可以简写为 hexo s</span><br><span class="line">hexo deploy#部署到服务器，可以简写为hexo d</span><br><span class="line">hexo new "文件名" #创建新文章</span><br><span class="line">hexo new draft "文件名" #创建草稿箱文章</span><br><span class="line">hexo new page "页面名" #创建新页面</span><br></pre></td></tr></table></figure><h3 id="配置部署到GitHub"><a href="#配置部署到GitHub" class="headerlink" title="配置部署到GitHub"></a>配置部署到GitHub</h3><p>首先要下载Git的插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>更改<code>_config.yml</code>配置文件的deploy部分。 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:<span class="comment">//github.com/xxx/xxx.github.io.git</span></span><br><span class="line">  branch: master#部署的分支</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git<span class="meta">@github</span>.com:xxx/xxx.github.io.git</span><br><span class="line">  branch: master#部署的分支</span><br></pre></td></tr></table></figure><h3 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>首先要有注册好的域名，没有的话，可以先去注册。域名的注册这里不多介绍了，资料很多，大家可以自己选择域名注册商进行注册。 </p><h3 id="CNAME类型解析"><a href="#CNAME类型解析" class="headerlink" title="CNAME类型解析"></a>CNAME类型解析</h3><p>注册好域名后，在博客的资源文件夹source下创建一个文件，<code>CNAME</code>，注意，这个文件没有后缀。使用文本编辑器打开，填入自己的域名，并保存。</p><p>登录自己的域名解析后台，添加一条解析记录。记录类型选择CNAME，记录值填入之前GItHub分配的访问路径<code>xxx.github.io</code>，保存后就可以用自己的域名访问博客了。</p><h3 id="A类型解析"><a href="#A类型解析" class="headerlink" title="A类型解析"></a>A类型解析</h3><p>在自己的域名解析后台添加一条解析记录，记录类型选择A，记录值填写自己项目访问路径的IP地址。如果不清楚IP地址，可以通过<code>ping 项目访问路径</code>的方式获得，然后填入记录值中即可。 </p><h3 id="修改GitHub仓库中的GitHub-Pages"><a href="#修改GitHub仓库中的GitHub-Pages" class="headerlink" title="修改GitHub仓库中的GitHub Pages"></a>修改GitHub仓库中的GitHub Pages</h3><p>在图中圈中地方输入自己的域名，然后点击save。</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1529659174536.png" alt=""></p><h2 id="Hexo更换NexT主题"><a href="#Hexo更换NexT主题" class="headerlink" title="Hexo更换NexT主题"></a>Hexo更换NexT主题</h2><h3 id="安装next主题"><a href="#安装next主题" class="headerlink" title="安装next主题"></a>安装next主题</h3><blockquote><p>其实可以使用的主题很多，但这里只介绍使用频率最多NexT的主题，因为网上有很多前辈的攻略博客，解决问题比较方便，如果有兴趣的话也可以自己取尝试一下其它主题。</p></blockquote><p>建议根据官方文档安装，写的十分详细，遇到不明白的地方再找别的资料参考 <a href="https://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT官方文档</a>，安装完成之后将</p><p><code>_config.yml</code> 文件中的<code>theme</code>字段，将值改为<code>next</code>。</p><h3 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h3><p>美化因为个人审美不同，就不在此处介绍了了，大家可以上网自行搜索，美化是个无休止的东西，建议够用就好</p><p>此处贴几个链接，方便大家使用。</p><p><a href="https://blog.csdn.net/qq_33699981/article/details/72716951" target="_blank" rel="noopener">hexo的next主题个性化教程：打造炫酷网站</a></p><p><a href="https://blog.csdn.net/mango_haoming/article/details/78207534" target="_blank" rel="noopener">Hexo+Pages静态博客-Next主题篇</a></p><p><a href="https://blog.csdn.net/miaoqiucheng/article/details/72794165" target="_blank" rel="noopener">基于Hexo+Next主题的个人博客搭建定制优化</a></p><hr>]]></content>
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot（一）：项目构建</title>
      <link href="/2018/06/06/SpringBoot%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"/>
      <url>/2018/06/06/SpringBoot%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528342168360.jpg" alt=""></p><a id="more"></a><h2 id="在IDE中使用Spring-Initializer快速构建Spring-Boot项目"><a href="#在IDE中使用Spring-Initializer快速构建Spring-Boot项目" class="headerlink" title="在IDE中使用Spring Initializer快速构建Spring Boot项目"></a>在IDE中使用Spring Initializer快速构建Spring Boot项目</h2><p>依次点击File，New，Project， 然后出现下面的界面。</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528540717977.png" alt=""></p><p>选择Spring Initializr，在Project SDK处选择JDK的版本，建议1.8及以上，当然1.7也可以使用，然后点击Next。</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528540718663.png" alt=""></p><p>输入项目名称之后点击Next。</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528540718882.png" alt=""></p><p>此处可以勾选所需要的一些组件，web按钮必须勾选，其它组件可以自由选择，例如Mysql，热部署之类的，在此处勾选之后，项目会自动下载相关的Jar包，当然也可以后期在pom.xml中自行添加。勾选之后点击Next。</p><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528540719069.png" alt=""></p><p>点击Finish完成，<font>当新项目创建完成后，右下角可能会出现一个弹框，选择靠右那个选项，会自动下载jar包。</font></p><h2 id="关于SpringBoot入口的一些注解"><a href="#关于SpringBoot入口的一些注解" class="headerlink" title="关于SpringBoot入口的一些注解"></a>关于SpringBoot入口的一些注解</h2><ul><li>@<strong>SpringBootApplication</strong>：这个注解所标明的类为SpringBoot程序的入口，通过运行这个类就可以启动SpringBoot应用（<font color="red">以下这些配置全是在@SpringBootApplication中引用的，对外暴露的注解其实只有@SpringBootApplication这个注解</font>）。</li><li>@<strong>SpringBootConfiguration</strong>：声明一个类是SpringBoot的配置类。<ul><li>@<strong>Configuration</strong>：声明一个类是配置类。</li></ul></li><li>@<strong>EnableAutoConfiguration</strong>：依靠注解的内部实现其能够完成自动配置的功能，将符合自动配置的条件引入到IOC容器中。<ul><li>@<strong>AutoConfigurationPackage</strong> ：自动配置包。</li><li>@<strong>Import</strong>(｛Registrar.class｝)：这个注解在Spring零碎知识收集中有提到，这里通过AutoConfigurationPackages.Registrar.class中的<font color="red">registerBeanDefinitions</font>方法，能够将主配置类（也就是被@<strong>SpringBootApplication</strong>标注的类）的所在包以及子包里所有的组件扫描到Spring容器中。</li><li>@<strong>Import</strong>(｛AutoConfigurationImporSelector.class｝)：这个注解通过AutoConfigurationImportSelector中的<font color="red">selectImports</font>方法，可以自动导入许多配置类。</li></ul></li><li><strong>@ComponentScan</strong>：开启组件扫描</li></ul><h2 id="关于SpringBoot的配置文件"><a href="#关于SpringBoot的配置文件" class="headerlink" title="关于SpringBoot的配置文件"></a>关于SpringBoot的配置文件</h2><h4 id="配置文件的几种形式"><a href="#配置文件的几种形式" class="headerlink" title="配置文件的几种形式"></a>配置文件的几种形式</h4><p>SpringBoot中主要使用两种配置文件：属性文件以及yml文件（xml文件也可以使用）。</p><p>属性文件的使用方式和之前一样，采用key=value的形式。</p><p>然后在变量上使用<code>@Value(&quot;${key}&quot;)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.uri-encoding=UTF-<span class="number">8</span></span><br><span class="line">spring.http.encoding.charset=UTF-<span class="number">8</span></span><br><span class="line">spring.http.encoding.enabled=<span class="keyword">true</span></span><br><span class="line">spring.http.encoding.force=<span class="keyword">true</span></span><br><span class="line">spring.messages.encoding=UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure><blockquote><p>当属性文件中的配置内容有中文时，可能会出现乱码，我们可以先在配置文件里添加上面的代码，然后在IntelliJ IDEA中依次点击File -&gt; Settings -&gt; Editor -&gt; File Encodings   将Properties Files (*.properties)下的Default encoding for properties files设置为UTF-8，将Transparent native-to-ascii conversion前的勾选上。 </p></blockquote><p>yml配置文件有固定的语法</p><ul><li><p>基本语法，key:(空格)value。yml中以空格的缩进来控制层级关系，左对齐的一列数据，都是同一个等级的。同时区分大小写</p></li><li><p>值的写法</p><ul><li><p>普通值（数字，字符传，布尔）：直接按照基本语法格式书写即可例如<code>name: zhangsan</code>，需要注意的是字符串不需要使用双引号或单引号，这两个符号有其它用法。</p></li><li><p>“”：被双引号括住的字符串，如果包含有特殊字符，字符会按照其表示的含义被识别，如<code>name: zhangsan \n 666</code>会被识别为<code>name: zhangsan 换行 666</code>。</p></li><li><p>‘’：被单引号括住的字符串，字符会被当做普通的字符串识别</p></li><li><p>对象，Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">people:</span><br><span class="line"> name: 张三</span><br><span class="line"> age: <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者可以使用单行写法</span></span><br><span class="line">people: &#123;name: 张三，age: <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组（List，Set）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list:</span><br><span class="line"> cat</span><br><span class="line"> dog</span><br><span class="line"> pig</span><br><span class="line"> </span><br><span class="line"><span class="comment">//单行写法</span></span><br><span class="line">list: [cat,dog,pig]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><p>如果我们在maven中添加了spring-boot-starter-logging依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>那么Spring Boot 将会自动使用logback作为日志框架，我们只需要创建一个logback-spring.xml配置文件即可。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;configuration  scan=<span class="string">"true"</span> scanPeriod=<span class="string">"60 seconds"</span> debug=<span class="string">"false"</span>&gt;</span><br><span class="line">    &lt;contextName&gt;logback&lt;/contextName&gt;</span><br><span class="line">    &lt;property name=<span class="string">"log.path"</span> value=<span class="string">"./logs"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 输出到控制台 --&gt;</span><br><span class="line">    &lt;appender name=<span class="string">"STDOUT"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %highlight(%-5level) %logger&#123;36&#125; - %highlight%msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 彩色日志格式 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">"log.pattern.color"</span> value=<span class="string">"$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%22.22t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;"</span> /&gt;</span><br><span class="line">    &lt;!-- 彩色日志依赖的渲染类 --&gt;</span><br><span class="line">    &lt;conversionRule conversionWord=<span class="string">"clr"</span> converterClass=<span class="string">"org.springframework.boot.logging.logback.ColorConverter"</span> /&gt;</span><br><span class="line">    &lt;conversionRule conversionWord=<span class="string">"wex"</span> converterClass=<span class="string">"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter"</span> /&gt;</span><br><span class="line">    &lt;conversionRule conversionWord=<span class="string">"wEx"</span> converterClass=<span class="string">"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter"</span> /&gt;</span><br><span class="line">    &lt;!-- 输出到控制台 --&gt;</span><br><span class="line">    &lt;appender name=<span class="string">"STDOUT_COLOR"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;$&#123;log.pattern.color&#125;&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 错误日志 --&gt;</span><br><span class="line">    &lt;appender name=<span class="string">"ERROR"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span><br><span class="line">        &lt;rollingPolicy <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span><br><span class="line">            &lt;!-- 按天生成文件 --&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;log.path&#125;/error/logback-error-%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;!-- 最多保存<span class="number">60</span>天内的日志 --&gt;</span><br><span class="line">            &lt;maxHistory&gt;60&lt;/maxHistory&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">        &lt;!-- 只打印错误日志 --&gt;</span><br><span class="line">        &lt;filter <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span><br><span class="line">            &lt;level&gt;ERROR&lt;/level&gt;</span><br><span class="line">            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;</span><br><span class="line">            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span><br><span class="line">        &lt;/filter&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--访问日志--&gt;</span><br><span class="line">    &lt;appender name=<span class="string">"ACCESS"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span><br><span class="line">        &lt;rollingPolicy <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span><br><span class="line">            &lt;!-- 按天生成文件 --&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;log.path&#125;/access/logback-access-%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;!-- 日志最大的历史 <span class="number">60</span>天 --&gt;</span><br><span class="line">            &lt;maxHistory&gt;60&lt;/maxHistory&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- info日志 --&gt;</span><br><span class="line">    &lt;appender name=<span class="string">"INFO"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span><br><span class="line">        &lt;rollingPolicy <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span><br><span class="line">            &lt;!-- 按天生成 --&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;log.path&#125;/info/logback-info-%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;!-- 日志最大的历史 <span class="number">60</span>天 --&gt;</span><br><span class="line">            &lt;maxHistory&gt;60&lt;/maxHistory&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">        &lt;!-- 只打印INFO日志 --&gt;</span><br><span class="line">        &lt;filter <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span><br><span class="line">            &lt;level&gt;INFO&lt;/level&gt;</span><br><span class="line">            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;</span><br><span class="line">            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span><br><span class="line">        &lt;/filter&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--日志打印的包的范围 --&gt;</span><br><span class="line">    &lt;logger name=<span class="string">"com.zbrx.speed"</span> additivity=<span class="string">"false"</span>&gt;</span><br><span class="line">        &lt;level value=<span class="string">"DEBUG"</span> /&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">"STDOUT"</span>/&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">"ERROR"</span>/&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">"ACCESS"</span>/&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">"INFO"</span> /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    &lt;!-- mybatis输出sql --&gt;</span><br><span class="line">    &lt;logger name="com.zbrx.speed.dao" level="DEBUG"&gt;&lt;/logger&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 控制台打印日志 --&gt;</span><br><span class="line">    &lt;root level=<span class="string">"INFO"</span>&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">"STDOUT_COLOR"</span> /&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ehcache食用教程</title>
      <link href="/2018/06/05/Ehcache%E9%A3%9F%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2018/06/05/Ehcache%E9%A3%9F%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528193012116.png" alt=""></p><a id="more"></a><h2 id="为什么使用Eacache"><a href="#为什么使用Eacache" class="headerlink" title="为什么使用Eacache"></a>为什么使用Eacache</h2><p>为了提高系统的运行效率，引入Ehcache可以减少对数据库的访问</p><h2 id="Eacache与Redis的取舍问题"><a href="#Eacache与Redis的取舍问题" class="headerlink" title="Eacache与Redis的取舍问题"></a>Eacache与Redis的取舍问题</h2><p>ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。<br>redis是通过socket访问到缓存服务，效率比ecache低，比数据库要快很多，处理集群和分布式缓存方便，有成熟的方案。</p><p>如果是单个应用或者对缓存访问要求很高的应用，用ehcache。<br>如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><font color="red">Encache所需要的jar包（版本可以自行更换）</font><ul><li>slf4j-api-1.6.1.jar</li><li>ehcache-core-2.1.0.jar</li><li>ehcache-spring-annotations-1.1.2.jar；</li><li>slf4j-log4j12-1.6.1.jar</li><li>spring-context-support-4.0.6.RELEASE.jar</li></ul><font color="red">创建ehcache.xml</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line"> &lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt;  </span><br><span class="line">      </span><br><span class="line">     &lt;!-- 缓存存储的位置 --&gt;</span><br><span class="line">     &lt;diskStore path=&quot;E：/ehcache&quot;/&gt;  </span><br><span class="line">       </span><br><span class="line">     &lt;!-- 默认缓存 --&gt;  </span><br><span class="line">     &lt;defaultCache  </span><br><span class="line">            maxElementsInMemory=&quot;1000&quot;  </span><br><span class="line">            eternal=&quot;false&quot;  </span><br><span class="line">            timeToIdleSeconds=&quot;120&quot;  </span><br><span class="line">            timeToLiveSeconds=&quot;120&quot;  </span><br><span class="line">            overflowToDisk=&quot;false&quot;/&gt;  </span><br><span class="line">              </span><br><span class="line">     &lt;!-- 自定义的缓存 --&gt;      </span><br><span class="line">     &lt;cache name=&quot;myCache&quot;   </span><br><span class="line">            maxElementsInMemory=&quot;1000&quot;   </span><br><span class="line">            eternal=&quot;false&quot;  </span><br><span class="line">            timeToIdleSeconds=&quot;120&quot;  </span><br><span class="line">            timeToLiveSeconds=&quot;120&quot;  </span><br><span class="line">            overflowToDisk=&quot;false&quot;   </span><br><span class="line">            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;  </span><br><span class="line">       </span><br><span class="line"> &lt;/ehcache&gt;</span><br></pre></td></tr></table></figure><p><strong>name</strong>：缓存名称,cache的唯一标识(ehcache会把这个cache放到HashMap里)。</p><p><strong>maxElementsOnDisk</strong>：磁盘缓存中最多可以存放的元素数量,0表示无穷大。</p><p><strong>maxElementsInMemory</strong>：内存缓存中最多可以存放的元素数量,若放入Cache中的元素超过这个数值,则有以下两种情况。</p><p>1)若overflowToDisk=true,则会将Cache中多出的元素放入磁盘文件中。</p><p>2)若overflowToDisk=false,则根据memoryStoreEvictionPolicy策略替换Cache中原有的元素。</p><p><strong>Eternal</strong>：缓存中对象是否永久有效,即是否永驻内存,true时将忽略timeToIdleSeconds和timeToLiveSeconds。</p><p><strong>timeToIdleSeconds</strong>：缓存数据在失效前的允许闲置时间(单位:秒),仅当eternal=false时使用,默认值是0表示可闲置时间无穷大,此为可选属性即访问这个cache中元素的最大间隔时间,若超过这个时间没有访问此Cache中的某个元素,那么此元素将被从Cache中清除。</p><p><strong>timeToLiveSeconds</strong>：缓存数据在失效前的允许存活时间(单位:秒),仅当eternal=false时使用,默认值是0表示可存活时间无穷大，即Cache中的某元素从创建到清楚的生存时间,也就是说从创建开始计时,当超过这个时间时,此元素将从Cache中清除。</p><p><strong>overflowToDisk</strong>：内存不足时,是否启用磁盘缓存(即内存中对象数量达到maxElementsInMemory时,Ehcache会将对象写到磁盘中)，会根据标签中path值查找对应的属性值,写入磁盘的文件会放在path文件夹下,文件的名称是cache的名称,后缀名是data。</p><p><strong>diskPersistent</strong>：是否持久化磁盘缓存,当这个属性的值为true时,系统在初始化时会在磁盘中查找文件名为cache名称,后缀名为index的文件，这个文件中存放了已经持久化在磁盘中的cache的index,找到后会把cache加载到内存，要想把cache真正持久化到磁盘,写程序时注意执行net.sf.ehcache.Cache.put(Element  element)后要调用flush()方法。</p><p><strong>diskExpiryThreadIntervalSeconds</strong>：磁盘缓存的清理线程运行间隔,默认是120秒。</p><p><strong>diskSpoolBufferSizeMB</strong>：设置DiskStore（磁盘缓存）的缓存区大小,默认是30MB</p><p><strong>memoryStoreEvictionPolicy</strong>：内存存储与释放策略,即达到maxElementsInMemory限制时,Ehcache会根据指定策略清理内存，共有三种策略,分别为LRU(最近最少使用)、LFU(最常用的)、FIFO(先进先出)。</p><font color="red">在Spring的配置文件加入如下配置</font><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 开启Ehcache --&gt;</span><br><span class="line">&lt;cache:annotation-driven cache-manager=<span class="string">"cacheManager"</span>/&gt;  </span><br><span class="line">      </span><br><span class="line">&lt;bean id=<span class="string">"cacheManagerFactory"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.cache.ehcache.EhCacheManagerFactoryBean"</span>&gt; </span><br><span class="line">        &lt;property name=<span class="string">"configLocation"</span> value=<span class="string">"classpath:application/ehcache.xml"</span> /&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">      </span><br><span class="line">&lt;bean id=<span class="string">"cacheManager"</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.cache.ehcache.EhCacheCacheManager"</span>&gt;   </span><br><span class="line">        &lt;property name=<span class="string">"cacheManager"</span>  ref=<span class="string">"cacheManagerFactory"</span>/&gt;      </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><font color="red">在方法上使用注解</font><p><strong>@Cacheable</strong>主要针对方法配置，能够根据方法的请求参数对其结果进行缓存。</p><table><thead><tr><th>value</th><th>缓存的名称，在 spring 配置文件中定义，必须指定至少一个</th><th>例如：  @Cacheable(value=” menuCache”) 或者   @Cacheable(value={”cache1”,”cache2”}</th></tr></thead><tbody><tr><td>key</td><td>缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td>例如：  @Cacheable(value=” menuCache”, key=”#userName”)</td></tr><tr><td>condition</td><td>缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存</td><td>例如：  @Cacheable(value=” menuCache”, condition=”#userName.length()&gt;2”)</td></tr></tbody></table><p><strong>@CachePut</strong>主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用。</p><table><thead><tr><th>value</th><th>缓存的名称，在 spring 配置文件中定义，必须指定至少一个</th><th>例如：  @Cacheable(value=” menuCache”) 或者   @Cacheable(value={”cache1”,”cache2”}</th></tr></thead><tbody><tr><td>key</td><td>缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td>例如：  @Cacheable(value=”testcache”, key=”#userName”)</td></tr><tr><td>condition</td><td>缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存</td><td>例如：  @Cacheable(value=” menuCache”, condition=”#userName.length()&gt;2”)</td></tr></tbody></table><p><strong>@CachEvict</strong>主要针对方法配置，能够根据一定的条件对缓存进行清空。</p><table><thead><tr><th>value</th><th>缓存的名称，在 spring 配置文件中定义，必须指定至少一个</th><th style="text-align:left">例如：  @CachEvict(value=” menuCache”) 或者   @CachEvict(value={”cache1”,”cache2”}</th></tr></thead><tbody><tr><td>key</td><td>缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td style="text-align:left">例如：  @CachEvict(value=” menuCache”, key=”#userName”)</td></tr><tr><td>condition</td><td>缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才清空缓存</td><td style="text-align:left">例如：  @CachEvict(value=” menuCache”,  condition=”#userName.length()&gt;2”)</td></tr><tr><td>allEntries</td><td>是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存</td><td style="text-align:left">例如：  @CachEvict(value=” menuCache”, allEntries=true)</td></tr><tr><td>beforeInvocation</td><td>是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存</td><td style="text-align:left">例如：  @CachEvict(value=” menuCache”，beforeInvocation=true)</td></tr></tbody></table><hr>]]></content>
      
      <categories>
          
          <category> Ehcache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ehcache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring零碎知识收集</title>
      <link href="/2018/05/23/Spring%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E6%94%B6%E9%9B%86/"/>
      <url>/2018/05/23/Spring%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E6%94%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1526290577726.jpg" alt=""></p><p>这篇博客主要是对《Spring实战》以及日常工作时发现的一些有关Spring的零碎知识进行收集，内容可能会很多而且不一定全都有用，当作一本字典食用即可。</p><a id="more"></a><ul><li><p>@<strong>DateTimeFormat</strong></p><ul><li>这个注解一般用在实体类的Date类型属性上，它可以将页面传递来的String类型日期转换为Date类型，但在4.0之前强依赖于joda-time.jar    ，必须要引入这个包才可以使用，4.0之后不再强依赖于这个jar包。</li></ul></li><li><p>&lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/fmt&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/fmt&quot;</a> prefix=”fmt” %&gt;</p><ul><li>这是一个jstl标签，其中有很多格式化的方法，比如格式化日期，数字等等，此处只做一个简单的记录，有需求可以直接百度，食用度不难。</li></ul></li><li><p>@<strong>Configuration</strong> </p><ul><li>这个注解相当于xml中的<code>&lt;beans&gt;&lt;beans/&gt;</code>标签，可以表明这个类是一个配置类，在SpringBoot中可能会用的比较多，而且在SpringBoot中不用开启注解扫描也可以直接使用。</li></ul></li><li><p>@<strong>ComponentScan</strong></p><ul><li>这个注解会开启注解扫描，有属性值value，相当于base-package。一般在配置类上使用，若不配置这个属性，它会默认以配置类所处的包为base-package来扫描组件。</li></ul></li><li><p>@<strong>Component</strong></p><ul><li>和@Controller，@Service这些用法一样，一般用于实例化实体类。</li></ul></li><li><p>@<strong>Named</strong>(“”)</p><ul><li>这个注解和上一个注解的用处一样，引号中的字符串可以当作bean的别名，@Component也可以通过这种方式来指定别名。</li></ul></li><li><p>@<strong>RunWith</strong>（SpringJUnit4ClassRunner.class）</p><ul><li>这个注解可以用在测试类上，测试时会自动加载Spring上下文。</li></ul></li><li><p>@<strong>ContextConfiguration</strong>（class=XXX.class）</p><ul><li>测试时与上一个注解搭配使用，这个注解可以指明哪一个类是配置类。</li></ul></li><li><p>@<strong>Inject</strong></p><ul><li>这个注解和@Autowired一样都是用于bean的自动装配，它和@Named注解都来自于Java的依赖注入规范，大部分情况下这两个注解是可以互相替换的。</li></ul></li><li><p>@<strong>Bean</strong>（name=””）</p><ul><li>这个注解相当于XML配置文件中的<code>&lt;bean&gt;&lt;/bean&gt;</code>标签，用于方法上，它可以通知Spring该方法会返回一个对象，这个对像将要注册为Spring应用上下文的bean。用这种方法创建bean时，使我们有了在方法体中执行复杂逻辑的可能性，因为这完全是基于Java代码的，无论逻辑多复杂，只要最终返回一个实力就行。另外当一个方法已经使用了这个注解后，Spring会拦截所有对它的访问，如果它已经创建了一个bean,，就会直接返回这个bean，而不是每次都对其进行实际的调用</li></ul></li><li><p>Spring配置的三种主要方式</p><ul><li>自动化配置<ul><li>工作时一般都使用这种方法，目前接触的项目多数情况下还会搭配XML，使用方法一般都是在XML里开启组件扫描，同时配置数据库，事务，拦截器等等，然后在代码中的使用@Controller，@Service，@Autowired这些注解。</li><li>虽然自动化配置很方便，但有些时候必须要显示的进行一些配置，比如在使用第三方的一些组件时，我们就没有办法去给它添加注解，除了上面所说的搭配XML，我们还可以搭配JavaConfig（基于Java的显示配置），使用这种方法时我们会创建一个类来取代XML，当我们为这个类加上@Configuration注解时，它就会被Spring认为是一个配置类，同时Spring也提供了大量的注解来对应XML中的标签，以便我能够实现所有XML中能够实现的功能，而且这种方法比XML更加强大。</li></ul></li><li>基于Java的显示配置<ul><li>正如上面所说的，我们在使用这种方法时可以创建一个类来取代XML，通过@Configuration来申明它是一个配置类，通过@ComponentScan来开启组件扫描，通过@Bean来创建实例等等，可能还有其它许多注解，但此处只做简单描述，未来可能在SpringBoot的学习中详细记录这种方式。</li></ul></li><li>基于XML的显示配置<ul><li>最原始的方法，见过无数次的<code>&lt;bean&gt;&lt;bean/&gt;</code>标签，<code>&lt;property/&gt;</code>标签等等，百度一抓一大把，基本也没什么可说的了。</li></ul></li></ul></li><li><p>@<strong>Import</strong>（XXX.calss）</p><ul><li>这个注解相当与XML中的<code>&lt;import&gt;</code>标签，在4.2前只能导入配置类，在4.2之后，@Import注解支持导入普通的Java类,并将其声明成一个bean ，当一个JavaConfig配置的内容过多，我们可以将其拆分为两个或更多的JavaConfig，通过使用这个注解将多个JavaConfig进行统一。同时也可以使用@<strong>Import</strong>（｛XXX.class,XXX.class｝）一次引入多个JavaConfig。</li></ul></li><li><p>@<strong>ImportResource</strong>(“classpath:”)</p><ul><li>这个注解和上一个注解的用处一样，是用来引入XML配置文件的</li></ul></li><li><p>条件化的bean</p><ul><li>当我们希望一个bean只有在满足一定的条件下时才会被创建，可以在方法上使用@<strong>Conditional</strong>（XXX.class）注解，XXX是一个我们自定义的类，它必须实现Condition接口，并且重写matches()方法，当这个方法返回true时，这个bean就会被创建，如果返回false，则不会创建。</li></ul></li><li><p>@<strong>Qualifier</strong>(“”)</p><ul><li>这个注解可以配合@Autowired或@Inject使用，这个注解应用于有一个以上的bean可以匹配自动装配，比如一个接口有三个实现类，在自动装配时使用的参数类型是接口而不是实现类，这时Spring就会无法分辨你想要将哪一个子类注入，便会抛出异常。@Qualifier(“”)注解可以通过在””中指明限定符（默认情况下使用bean的id即可），从而准确的注入我们想要的bean。我们也可以不使用bean的id，自己来定义限定符，将@Qualifier(“”)和@Component，@Bean这类用于实例化的一起使用，””中的内容就是自定义的限定符</li></ul></li><li><p>@<strong>Scope</strong>()</p><ul><li>这个注解是用来声明bean的作用域的，在Spring中默认的作用域为Singleton，我们可以通过value属性将其改变为Prototype(多例)，Session(会话)，Request(请求)</li><li>proxyMode属性：这个属性可以解决将Session或Request作用域的bean注入到单例bean中所遇到的问题。当向一个单例的bean注入Session范围的或Request范围的bean时，它们此时并没有创建，直到一个用户发起了一个会话或进行了一次请求，它们才会被创建。<ul><li>以电子商务中的购物车系统为例，ShoppingCart实例的作用范围都是Session，而处理业务的ShoppingCartService都是单例的，当我们向ShoppingCartService中注入一个ShoppingCart时，这个ShoppingCart可能还没有被创建，直到一个用户发起了一次会话，ShoppingCart才会被创建，另外在向ShoppingCartService注入ShoppingCart时，我们并不希望注入的是一个固定的ShoppingCart实例，我们希望的时当ShoppingCartService处理购物车功能时，它所使用的ShoppingCart正好是当前会话的对应的那一个。所以Spring会注入一个ShoppingCart bean的代理，这个代理会暴露与ShoppingCart相同的方法，所以ShoppingService会认为它就是一个ShoppingsCart，但是在调用ShoppingCart中的方法时，代理会对其进行懒解析并将调用委托给会话作用域内真正的ShoppingCart bean。这个属性有两个常用的值，以ShoppingCart为例，假如ShoppingCart是一个接口，那么proxyMode的值是ScopedProxyMode.INTERFACES，如果ShoppingCart是一个类，那么proxyMode的值是ScopedProxyMode.TARGET_CLASS</li></ul></li><li><code>&lt;aop:scoped-proxy&gt;</code>：这个标签就是XML中proxyMode的用法，默认使用ScopedProxyMode.TARGET_CLASS，也可以将proxy-target-class设为false，将其变成基于接口的代理，需要注意的是使用这个注解需要开启aop命名空间。</li></ul></li><li><p>Spring中关于AOP的一些注解</p><ul><li>@<strong>EnableAspectJAutoProxy</strong>：这个注解可以用在配置类上，作用与组件扫描类似，开启之后可以识别@Aspect注解，如果是在XML中，可以使用Spring aop命名空间中的<code>&lt;aop:aspectj-autoproxy&gt;</code></li><li>@<strong>Aspect</strong>：这个注解可以标明一个类是切面。</li><li>@<strong>Before</strong>()：应用这个注解的方法会在目标方法调用之<font color="red">前</font>执行。</li><li>@<strong>After</strong>()：应用这个注解的方法会在目标方法调用之<font color="red">后</font>执行。</li><li>@<strong>AfterReturning</strong>()：应用这个注解的方法会在目标方法<font color="red">返回后</font>执行。</li><li>@<strong>AfterThrowing</strong>()：应用这个注解的方法会在目标方法<font color="red">抛出异常后</font>执行。</li><li>@<strong>Around</strong>()：应用这个注解的方法会在目标方法<font color="red">执行之前与执行之后</font>执行。</li><li>@<strong>Pointcut</strong>()：这个注解能够在切面内定义可以复用的切点。</li></ul></li><li><p>如果使用基于Java的配置方式作为配置文件，在配置web.xml时需要注意两点：</p><ul><li><p>在配置上下文关系时，原先指定xml的路径要变成JavaConfig的路径</p></li><li><p>要额外在web.xml中声明使用Java配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">&lt;param-name&gt;contextClass&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;</span><br><span class="line">org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line"></span><br><span class="line">在servlet标签中使用</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;contextClass&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;</span><br><span class="line">org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p>​    </p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring实战第四版</title>
      <link href="/2018/05/12/Spring%E5%AE%9E%E6%88%98%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
      <url>/2018/05/12/Spring%E5%AE%9E%E6%88%98%E7%AC%AC%E5%9B%9B%E7%89%88/</url>
      <content type="html"><![CDATA[<p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1526290577726.jpg" alt=""></p><p>写这篇博客是因为发现虽然平时工作中经常和Spring打交道。但是重复的造车轮工作并没有帮助我更好的去理解它，所以开始研究《Spring实战第四版》这本书，以便对Spring进行更近一步的学习。</p><a id="more"></a><h2 id="Spring基本理念"><a href="#Spring基本理念" class="headerlink" title="Spring基本理念"></a>Spring基本理念</h2><p>Spring最基本的理念就是简化代码开发，再抛开一切外壳之后，最终的基本策略都会回归到以下四点</p><ol><li>基于POJO的轻量级和最小侵入性编程</li><li>通过依赖注入和面向接口实现松耦合</li><li>基于切面和惯例进行声明式编程</li><li>通过切面和模板减少样板式代码</li></ol><h2 id="DI（依赖注入）"><a href="#DI（依赖注入）" class="headerlink" title="DI（依赖注入）"></a>DI（依赖注入）</h2><p>我觉得可以从三个问题来理解一下DI</p><ol><li>什么是DI？</li><li>DI能够做什么？</li><li>它是如何做到的？</li></ol><p>对于第一第二个问题，比较理论化一点，简单描述一下：DI发展到如今，已经变成了一种编程技巧和程序设计理念，它能够极大的降低程序的耦合性，还可以使代码的测试变得简单。</p><p>（关于耦合：这是一个具有两面性的东西，过高的耦合性会使代码难于测试，理解以及复用，同时可能会出现连锁式的BUG，修复好一个，又出现一个或多个新BUG，但完全没有耦合性的代码也没啥用，    想要完成有实际意义的功能，代码之间必须有适当的交互过程）</p><p>至于对于第三个问题可能是需要重点关注的：依赖注入能够降低高耦合性的问题是因为<font color="red">它不再让调用者来主动创建被调用者的实例，而是将其交给Spring来执行</font></p><h2 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP(面向切面编程)"></a>AOP(面向切面编程)</h2><p>在软件开发中，同一个功能如果散布于应用中多处，我们可以称其为横切关注点。从概念上来说我们应该将其与业务逻辑分离（但是往往会直接嵌入到业务逻辑之中）。AOP要做的就是把这些横切关注点与业务逻辑相分离。</p><p>DI能够实现应用对象之间的解耦，而AOP可以实现横切关注点与它们所影响的对象之间的解耦</p><p>关于AOP术语的理解：通知包含了用于多个应用对象的横切行为，连接点是程序中可以应用通知的所有点，切点定义了通知被应用的具体位置（也可以理解为切点定义了哪些连接点会得到通知），切点与通知的结合称为切面，将切面应用到目标对象并创建新的代理对象叫做织入，在目标对像的生命周期里有多个点可以进行织入</p><ol><li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器，它可以在目标类被引入引用之前增强该目标类的字节码。AspectJ 5的加载时织入就支持以这种方式织入切面</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态的创建一个代理对象。Spring AOP就是以这种方式织入切面的</li></ol><p>关于Spring AOP框架的一些关键知识</p><ol><li>Spring的通知是由Java编写的</li><li>Spring在运行时通知对象：代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean，当代理拦截到方法调用时，在调用目标bean的方法之前，会执行切面逻辑。<img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1529893029104.png" alt=""></li><li>Spring只支持方法级别的连接点</li></ol><p>##</p><hr>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简单写点东西撑撑首页</title>
      <link href="/2018/05/11/%E7%AE%80%E5%8D%95%E5%86%99%E7%82%B9%E4%B8%9C%E8%A5%BF%E6%92%91%E6%92%91%E9%A6%96%E9%A1%B5/"/>
      <url>/2018/05/11/%E7%AE%80%E5%8D%95%E5%86%99%E7%82%B9%E4%B8%9C%E8%A5%BF%E6%92%91%E6%92%91%E9%A6%96%E9%A1%B5/</url>
      <content type="html"><![CDATA[<h3 id="来自博主的碎碎念"><a href="#来自博主的碎碎念" class="headerlink" title="来自博主的碎碎念"></a><center>来自博主的碎碎念<center></center></center></h3><p><img src="http://bokephoto-1256720954.cos.ap-beijing.myqcloud.com/1528194439532.jpg" alt=""></p><a id="more"></a><blockquote class="blockquote-center"><p>嗯，闲鱼玩家终于也有的自己的博客了</p><p>激动ING</p><p>虽然布局很一般，但是会慢慢优化的（才怪）</p><p>毕竟博主是一个专业的前端工程师（手动滑稽）</p><p>CSS什么的根本不（wan）在（quan）话（bu）下（dong）</p><p>凭借我出色的审美</p><p>一定<del>不</del>会好好考虑如何搭配颜色，合理布局的</p><p>相信假以时日这个博客必定能够红红火火恍恍惚惚哈哈哈哈</p><hr><p>来自没有良心的博主(大英雄，你np满了)</p></blockquote>]]></content>
      
      <categories>
          
          <category> 即兴乱写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BB </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
